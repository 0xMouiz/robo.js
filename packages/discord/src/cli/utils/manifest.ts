import fs from 'node:fs/promises'
import path from 'node:path'
import { BaseConfig, CommandConfig, CommandOption, Config, EventConfig, Manifest, Plugin } from '../../types/index.js'
import { logger } from '../../core/logger.js'
import { hasProperties, packageJson } from './utils.js'
import { loadConfig } from './config.js'
import { exec } from 'node:child_process'
import { promisify } from 'node:util'
import { pathToFileURL } from 'node:url'
import { DefaultGen } from './generate-defaults.js'

const execAsync = promisify(exec)

// Global manifest reference
let _manifest: Manifest = null

/**
 * Returns the currently loaded manifest.
 * May return null if manifest has yet to load. Use `loadManifest` to load it first.
 */
export function getManifest(): Manifest | null {
	return _manifest
}

type DirType = 'command' | 'event' | 'lifecycle'

const BASE_MANIFEST: Manifest = {
	__README: 'This file was automatically generated by Robo. Do not edit it manually.',
	__robo: {
		config: null
	},
	commands: {},
	events: {}
}

const mergeEvents = (baseEvents: Record<string, EventConfig[]>, newEvents: Record<string, EventConfig[]>) => {
	const mergedEvents = { ...baseEvents }

	for (const eventName in newEvents) {
		const baseEventArray = mergedEvents[eventName] || []
		const newEventArray = newEvents[eventName]

		mergedEvents[eventName] = [...baseEventArray, ...newEventArray]
	}

	return mergedEvents
}

export async function generateManifest(generatedDefaults: DefaultGen): Promise<Manifest> {
	const config = await loadConfig()
	const pluginsManifest = await readPluginManifest(config?.plugins)
	const commands = await generateObjectFromDirectory<CommandConfig>(
		'.robo/build/commands',
		'command',
		generatedDefaults
	)
	const events = (await generateObjectFromDirectory<EventConfig>(
		'.robo/build/events',
		'event',
		generatedDefaults
	)) as Record<string, EventConfig[]>

	const newManifest: Manifest = {
		...BASE_MANIFEST,
		...pluginsManifest,
		__robo: {
			config: redactPluginOptions(config),
			updatedAt: new Date().toISOString(),
			version: packageJson.version
		},
		commands: {
			...pluginsManifest.commands,
			...commands
		} as Record<string, CommandConfig>,
		events: mergeEvents(pluginsManifest.events, events)
	}

	// Make sure newManifest commands are in alphabetical order
	newManifest.commands = Object.fromEntries(Object.entries(newManifest.commands).sort(([a], [b]) => a.localeCompare(b)))
	newManifest.events = Object.fromEntries(Object.entries(newManifest.events).sort(([a], [b]) => a.localeCompare(b)))

	// Our new source of truth is ready!
	await fs.writeFile(path.join('.robo', 'manifest.json'), JSON.stringify(newManifest, null, 2))
	logger.debug(`Generated manifest:`, newManifest)
	return newManifest
}

async function readPluginManifest(plugins: Plugin[]): Promise<Manifest> {
	let pluginsManifest = BASE_MANIFEST
	if (!plugins?.length) {
		return pluginsManifest
	}

	logger.debug(`Reading plugins...`, plugins)
	for (const plugin of plugins) {
		const pluginName = typeof plugin === 'string' ? plugin : plugin[0]
		const packagePath = await findPackagePath(pluginName, process.cwd())
		const manifest = await loadManifest(pluginName, packagePath)

		pluginsManifest = {
			...pluginsManifest,
			commands: {
				...pluginsManifest.commands,
				...manifest.commands
			},
			events: {
				...pluginsManifest.events,
				...manifest.events
			}
		}
	}

	return pluginsManifest
}

export async function loadManifest(name = '', basePath = ''): Promise<Manifest> {
	const manifestPath = path.join(basePath || '.', '.robo', 'manifest.json')
	let manifest: Manifest

	try {
		const manifestContent = await fs.readFile(manifestPath, 'utf-8')
		if (!manifestContent?.trim()) {
			manifest = BASE_MANIFEST
			return manifest
		}
		manifest = JSON.parse(manifestContent) as Manifest

		// Inject plugin info if this is being built as a plugin
		if (name && basePath) {
			const pluginInfo: BaseConfig = {
				__auto: true,
				__plugin: {
					name,
					path: basePath
				}
			}

			Object.keys(manifest.commands).forEach((key) => {
				manifest.commands[key].__auto = true
				manifest.commands[key].__plugin = {
					name,
					path: basePath
				}
			})
			Object.keys(manifest.events).forEach((key) => {
				manifest.events[key] = manifest.events[key].map((eventConfig) => ({
					...pluginInfo,
					...eventConfig
				}))
			})
		}

		return manifest
	} catch (e) {
		if (hasProperties<{ code: unknown }>(e, ['code']) && e.code === 'ENOENT') {
			manifest = BASE_MANIFEST
			return manifest
		}
		throw e
	} finally {
		_manifest = manifest
	}
}

async function generateObjectFromDirectory<T>(
	dirPath: string,
	type: DirType,
	generatedDefaults: DefaultGen,
	rootKey?: string
): Promise<Record<string, T | T[]>> {
	try {
		const files = await fs.readdir(dirPath)

		const objects = await Promise.all(
			files.map(async (file) => {
				const fullPath = path.resolve(dirPath, file)
				const stats = await fs.stat(fullPath)

				if (stats.isDirectory()) {
					const nestedObjects = await generateObjectFromDirectory<T>(fullPath, type, generatedDefaults, rootKey || file)
					return Object.entries(nestedObjects).map(([key, value]) => ({
						key: rootKey ? `${rootKey}/${key}` : key,
						value
					}))
				} else if (path.extname(file) === '.js') {
					const key = path.basename(file, path.extname(file))
					const generated = type === 'command' ? generatedDefaults?.commands : generatedDefaults?.events
					const isGenerated = generated && Object.keys(generated).includes(rootKey ?? key)
					const importPath = pathToFileURL(fullPath).toString()
					const module = await import(importPath)
					const value: T = getValue(type, module.config) as T
					return {
						key: rootKey || key,
						value: {
							...value,
							__auto: isGenerated ? true : undefined,
							__path: rootKey ? rootKey + '/' + file : file
						}
					}
				}

				return null
			})
		)

		return objects
			.flat()
			.filter((obj) => obj !== null)
			.reduce((acc, obj) => {
				if (obj) {
					if (type === 'event') {
						if (!acc[obj.key]) {
							acc[obj.key] = []
						}
						const currentArray = acc[obj.key] as T[]
						if (Array.isArray(obj.value)) {
							currentArray.push(...(obj.value as T[]))
						} else {
							currentArray.push(obj.value as T)
						}
						acc[obj.key] = currentArray
					} else {
						acc[obj.key] = obj.value as T
					}
				}
				return acc
			}, {} as Record<string, T | T[]>)
	} catch (error) {
		if (hasProperties<{ code: unknown }>(error, ['code']) && error.code === 'ENOENT') {
			return {} as Record<string, T | T[]>
		}
		throw error
	}
}

type AllConfig = CommandConfig & EventConfig
function getValue<T extends AllConfig>(type: DirType, config: BaseConfig): T {
	const value = {} as T
	if (!config) {
		return value
	}

	if (type === 'command' && config) {
		if ((config as CommandConfig).description) {
			value.description = (config as CommandConfig).description
		}
		if ((config as CommandConfig).descriptionLocalizations) {
			value.descriptionLocalizations = (config as CommandConfig).descriptionLocalizations
		}
		if ((config as CommandConfig).options) {
			value.options = (config as CommandConfig).options.map((option) => {
				const optionValue: CommandOption = {
					name: option.name
				}
				if (option.autocomplete) {
					optionValue.autocomplete = option.autocomplete
				}
				if (option.description) {
					optionValue.description = option.description
				}
				if (option.descriptionLocalizations) {
					optionValue.descriptionLocalizations = option.descriptionLocalizations
				}
				if (option.nameLocalizations) {
					optionValue.nameLocalizations = option.nameLocalizations
				}
				if (option.required) {
					optionValue.required = option.required
				}
				if (option.type) {
					optionValue.type = option.type
				}
				return optionValue
			})

			// Sort options order by required
			value.options.sort((a, b) => {
				if (a.required && !b.required) {
					return -1
				}
				if (!a.required && b.required) {
					return 1
				}
				return 0
			})

			if ((config as CommandConfig).sage !== undefined) {
				value.sage = (config as CommandConfig).sage
			}
		}
	}
	if (type === 'event' && config) {
		value.frequency = (config as EventConfig).frequency ?? 'always'
	}

	if (config.__auto) {
		value.__auto = true
	}

	if (config.timeout !== undefined) {
		value.timeout = config.timeout
	}

	// Sort values order by key
	return Object.keys(value)
		.sort()
		.reduce((acc, key) => {
			acc[key as keyof T] = value[key as keyof T]
			return acc
		}, {} as T)
}

async function findNodeModules(basePath: string): Promise<string | null> {
	const nodeModulesPath = path.join(basePath, 'node_modules')
	try {
		await fs.access(nodeModulesPath)
		return nodeModulesPath
	} catch (error) {
		const parentPath = path.resolve(basePath, '..')
		if (parentPath !== basePath) {
			return findNodeModules(parentPath)
		} else {
			return null
		}
	}
}

async function findPackagePath(packageName: string, currentPath: string): Promise<string | null> {
	const nodeModulesPath = await findNodeModules(currentPath)
	if (!nodeModulesPath) {
		logger.debug(`Could not find node_modules folder for ${packageName}`)
		return null
	}

	const pnpmNodeModulesPath = path.resolve(nodeModulesPath, '.pnpm')
	const isPnpm = await fs.access(pnpmNodeModulesPath).then(
		() => true,
		() => false
	)

	let packagePath: string | null = null

	if (isPnpm) {
		logger.debug(`Found pnpm node_modules folder for ${packageName}`)
		try {
			const { stdout } = await execAsync(`pnpm list ${packageName} --json`, { cwd: currentPath })
			const packages = JSON.parse(stdout)
			const packageInfo = Array.isArray(packages) ? packages[0] : packages
			packagePath = packageInfo.dependencies[packageName].path
		} catch (error) {
			logger.error('', error)
		}
	} else {
		const candidatePath = path.join(nodeModulesPath, packageName)
		logger.debug(`Checking for ${packageName} in ${candidatePath}`)
		try {
			await fs.access(candidatePath)
			packagePath = candidatePath
		} catch (error) {
			// Do nothing
		}
	}

	if (packagePath) {
		return path.relative(process.cwd(), packagePath)
	}

	const parentPath = path.resolve(nodeModulesPath, '..')
	return parentPath !== currentPath ? findPackagePath(packageName, parentPath) : null
}

/**
 * We should not include plugin option values in the manifest.
 * They may contain sensitive information such as API keys or passwords.
 */
function redactPluginOptions(config: Config): Config {
	if (!config.plugins) {
		return config
	}

	const redactedPlugins = config.plugins.map((plugin): Plugin => {
		if (Array.isArray(plugin)) {
			const [pluginName, pluginOptions] = plugin

			if (typeof pluginOptions === 'object') {
				const redactedObj: Record<string, unknown> = {}

				for (const key in pluginOptions as Record<string, unknown>) {
					if (Object.prototype.hasOwnProperty.call(pluginOptions as Record<string, unknown>, key)) {
						redactedObj[key] = '[REDACTED]'
					}
				}

				return [pluginName, redactedObj]
			}
		}

		return plugin
	})

	return {
		...config,
		plugins: redactedPlugins
	}
}
