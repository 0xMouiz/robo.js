import fs from 'node:fs/promises'
import path from 'node:path'
import {
	BaseConfig,
	CommandConfig,
	CommandOption,
	Config,
	EventConfig,
	Manifest,
	Plugin,
	Scope
} from '../../types/index.js'
import { logger } from '../../core/logger.js'
import { findPackagePath, hasProperties, packageJson } from './utils.js'
import { loadConfig } from '../../core/config.js'
import { pathToFileURL } from 'node:url'
import { DefaultGen } from './generate-defaults.js'
import type { PermissionsString } from 'discord.js'

// Global manifest reference
let _manifest: Manifest = null

/**
 * Returns the currently loaded manifest.
 * May return null if manifest has yet to load. Use `loadManifest` to load it first.
 */
export function getManifest(): Manifest | null {
	return _manifest
}

type DirType = 'command' | 'event' | 'lifecycle'

const BASE_MANIFEST: Manifest = {
	__README: 'This file was automatically generated by Robo. Do not edit it manually.',
	__robo: {
		config: null,
		type: 'robo'
	},
	commands: {},
	events: {},
	permissions: [],
	scopes: []
}

// TODO: Replace with file scanning to detect actual usage
// Bot permissions are not directly tied to intents
const INTENT_PERMISSIONS: Record<string, PermissionsString[]> = {
	DirectMessages: [],
	DirectMessageReactions: [],
	DirectMessageTyping: [],
	Guilds: ['ViewChannel'],
	GuildMembers: [],
	GuildBans: ['BanMembers', 'ViewAuditLog'],
	GuildEmojisAndStickers: ['ManageEmojisAndStickers'],
	GuildIntegrations: ['ManageGuild', 'ViewAuditLog'],
	GuildWebhooks: ['ManageWebhooks', 'ViewAuditLog'],
	GuildInvites: ['CreateInstantInvite', 'ManageGuild'],
	GuildVoiceStates: ['Connect', 'Speak', 'MuteMembers', 'DeafenMembers', 'MoveMembers', 'UseVAD'],
	GuildPresences: [],
	GuildMessages: ['ReadMessageHistory', 'SendMessages'],
	GuildMessageReactions: ['ReadMessageHistory', 'AddReactions'],
	GuildMessageTyping: ['ReadMessageHistory']
}

const mergeEvents = (baseEvents: Record<string, EventConfig[]>, newEvents: Record<string, EventConfig[]>) => {
	const mergedEvents = { ...baseEvents }

	for (const eventName in newEvents) {
		const baseEventArray = mergedEvents[eventName] || []
		const newEventArray = newEvents[eventName]

		mergedEvents[eventName] = [...baseEventArray, ...newEventArray]
	}

	return mergedEvents
}

export async function generateManifest(generatedDefaults: DefaultGen, type: 'plugin' | 'robo'): Promise<Manifest> {
	const config = await loadConfig()
	const pluginsManifest = type === 'plugin' ? BASE_MANIFEST : await readPluginManifest(config?.plugins)
	const commands = await generateObjectFromDirectory<CommandConfig>(
		'.robo/build/commands',
		'command',
		generatedDefaults
	)
	logger.debug(`Found ${Object.keys(commands).length} commands`)
	const events = (await generateObjectFromDirectory<EventConfig>(
		'.robo/build/events',
		'event',
		generatedDefaults
	)) as Record<string, EventConfig[]>
	logger.debug(`Found ${Object.keys(events).length} events`)

	const newManifest: Manifest = {
		...BASE_MANIFEST,
		...pluginsManifest,
		__robo: {
			config: redactPluginOptions(config),
			type: type,
			updatedAt: new Date().toISOString(),
			version: packageJson.version
		},
		commands: {
			...pluginsManifest.commands,
			...commands
		} as Record<string, CommandConfig>,
		events: mergeEvents(pluginsManifest.events, events)
	}

	// Smartly detect permissions and scopes
	newManifest.permissions = await generatePermissions(config)
	newManifest.scopes = generateScopes(config, newManifest)

	// Make sure newManifest commands are in alphabetical order
	newManifest.commands = Object.fromEntries(Object.entries(newManifest.commands).sort(([a], [b]) => a.localeCompare(b)))
	newManifest.events = Object.fromEntries(Object.entries(newManifest.events).sort(([a], [b]) => a.localeCompare(b)))

	// Our new source of truth is ready!
	await fs.mkdir('.robo', { recursive: true })
	await fs.writeFile(path.join('.robo', 'manifest.json'), JSON.stringify(newManifest, null, 2))
	logger.debug(`Generated manifest:`, newManifest)
	return newManifest
}

async function readPluginManifest(plugins: Plugin[]): Promise<Manifest> {
	let pluginsManifest = BASE_MANIFEST
	if (!plugins?.length) {
		return pluginsManifest
	}

	logger.debug(`Reading plugins...`, plugins)
	for (const plugin of plugins) {
		const pluginName = typeof plugin === 'string' ? plugin : plugin[0]
		const packagePath = await findPackagePath(pluginName, process.cwd())
		const manifest = await loadManifest(pluginName, packagePath)

		// For now, we only supporting merging plugin permissions as strings
		const validPermissions = manifest.permissions && typeof manifest.permissions !== 'number'

		pluginsManifest = {
			...pluginsManifest,
			commands: {
				...pluginsManifest.commands,
				...manifest.commands
			},
			events: {
				...pluginsManifest.events,
				...manifest.events
			},
			permissions: [
				...(pluginsManifest.permissions as PermissionsString[]),
				...(validPermissions ? (manifest.permissions as PermissionsString[]) : [])
			],
			scopes: [...pluginsManifest.scopes, ...(manifest.scopes ?? [])]
		}
	}

	return pluginsManifest
}

export async function loadManifest(name = '', basePath = ''): Promise<Manifest> {
	const manifestPath = path.join(basePath || '.', '.robo', 'manifest.json')
	let manifest: Manifest

	try {
		const manifestContent = await fs.readFile(manifestPath, 'utf-8')
		if (!manifestContent?.trim()) {
			manifest = BASE_MANIFEST
			return manifest
		}
		manifest = JSON.parse(manifestContent) as Manifest

		// Inject plugin info if this is being built as a plugin
		if (name && basePath) {
			const pluginInfo: BaseConfig = {
				__auto: true,
				__plugin: {
					name,
					path: basePath
				}
			}

			Object.keys(manifest.commands).forEach((key) => {
				manifest.commands[key].__auto = true
				manifest.commands[key].__plugin = {
					name,
					path: basePath
				}
			})
			Object.keys(manifest.events).forEach((key) => {
				manifest.events[key] = manifest.events[key].map((eventConfig) => ({
					...pluginInfo,
					...eventConfig
				}))
			})
		}

		return manifest
	} catch (e) {
		if (hasProperties<{ code: unknown }>(e, ['code']) && e.code === 'ENOENT') {
			manifest = BASE_MANIFEST
			return manifest
		}
		throw e
	} finally {
		_manifest = manifest
	}
}

async function generatePermissions(config: Config): Promise<PermissionsString[]> {
	const permissions: PermissionsString[] = []
	const autoPermissions = config?.invite?.autoPermissions ?? true

	if (autoPermissions) {
		// Scan all intents to come up with a list of permissions we need
		const intents = Object.values(config.clientOptions?.intents || {})
		for (const intent of intents) {
			if (typeof intent === 'string') {
				// Determine what permissions this intent requires
				const intentPermissions = INTENT_PERMISSIONS[intent]
				if (intentPermissions) {
					permissions.push(...intentPermissions)
				}
			}
		}
	}

	// Include all permissions specified in the config
	const configPermissions = config.invite?.permissions
	if (typeof configPermissions !== 'number' && configPermissions?.length) {
		permissions.push(...configPermissions)
	}

	// Sort permissions alphabetically (this is very important to me)
	permissions.sort((a, b) => a.localeCompare(b))

	// Filter out duplicates and nulls before returning
	return [...new Set(permissions)].filter((permission) => permission)
}

function generateScopes(config: Config, newManifest: Manifest): Scope[] {
	const scopes: Scope[] = ['bot']

	// Include application.commands if there are any commands in the manifest
	if (Object.keys(newManifest.commands).length) {
		scopes.push('applications.commands')
	}

	// Include all scopes specified in the config
	if (config.invite?.scopes?.length) {
		scopes.push(...config.invite.scopes)
	}

	// Sort scopes alphabetically (this is very important to me)
	scopes.sort((a, b) => a.localeCompare(b))

	// Filter out duplicates and nulls before returning
	return [...new Set(scopes)].filter((scope) => scope)
}

async function generateObjectFromDirectory<T>(
	dirPath: string,
	type: DirType,
	generatedDefaults: DefaultGen,
	rootKey?: string
): Promise<Record<string, T | T[]>> {
	try {
		const files = await fs.readdir(dirPath)

		const objects = await Promise.all(
			files.map(async (file) => {
				const fullPath = path.resolve(dirPath, file)
				const stats = await fs.stat(fullPath)

				if (stats.isDirectory()) {
					const nestedObjects = await generateObjectFromDirectory<T>(fullPath, type, generatedDefaults, rootKey || file)
					return Object.entries(nestedObjects).map(([key, value]) => ({
						key: rootKey ? `${rootKey}/${key}` : key,
						value
					}))
				} else if (path.extname(file) === '.js') {
					const key = path.basename(file, path.extname(file))
					const generated = type === 'command' ? generatedDefaults?.commands : generatedDefaults?.events
					const isGenerated = generated && Object.keys(generated).includes(rootKey ?? key)
					const importPath = pathToFileURL(fullPath).toString()
					const module = await import(importPath)
					const value: T = getValue(type, module.config) as T
					return {
						key: rootKey || key,
						value: {
							...value,
							__auto: isGenerated ? true : undefined,
							__path: rootKey ? rootKey + '/' + file : file
						}
					}
				}

				return null
			})
		)

		return objects
			.flat()
			.filter((obj) => obj !== null)
			.reduce((acc, obj) => {
				if (obj) {
					if (type === 'event') {
						if (!acc[obj.key]) {
							acc[obj.key] = []
						}
						const currentArray = acc[obj.key] as T[]
						if (Array.isArray(obj.value)) {
							currentArray.push(...(obj.value as T[]))
						} else {
							currentArray.push(obj.value as T)
						}
						acc[obj.key] = currentArray
					} else {
						acc[obj.key] = obj.value as T
					}
				}
				return acc
			}, {} as Record<string, T | T[]>)
	} catch (error) {
		if (hasProperties<{ code: unknown }>(error, ['code']) && error.code === 'ENOENT') {
			return {} as Record<string, T | T[]>
		}
		throw error
	}
}

type AllConfig = CommandConfig & EventConfig
function getValue<T extends AllConfig>(type: DirType, config: BaseConfig): T {
	const value = {} as T
	if (!config) {
		return value
	}

	if (type === 'command' && config) {
		if ((config as CommandConfig).description) {
			value.description = (config as CommandConfig).description
		}
		if ((config as CommandConfig).descriptionLocalizations) {
			value.descriptionLocalizations = (config as CommandConfig).descriptionLocalizations
		}
		if ((config as CommandConfig).options) {
			value.options = (config as CommandConfig).options.map((option) => {
				const optionValue: CommandOption = {
					name: option.name
				}
				if (option.autocomplete) {
					optionValue.autocomplete = option.autocomplete
				}
				if (option.description) {
					optionValue.description = option.description
				}
				if (option.descriptionLocalizations) {
					optionValue.descriptionLocalizations = option.descriptionLocalizations
				}
				if (option.nameLocalizations) {
					optionValue.nameLocalizations = option.nameLocalizations
				}
				if (option.required) {
					optionValue.required = option.required
				}
				if (option.type) {
					optionValue.type = option.type
				}
				return optionValue
			})

			// Sort options order by required
			value.options.sort((a, b) => {
				if (a.required && !b.required) {
					return -1
				}
				if (!a.required && b.required) {
					return 1
				}
				return 0
			})

			if ((config as CommandConfig).sage !== undefined) {
				value.sage = (config as CommandConfig).sage
			}
		}
	}
	if (type === 'event' && config) {
		value.frequency = (config as EventConfig).frequency ?? 'always'
	}

	if (config.__auto) {
		value.__auto = true
	}

	if (config.timeout !== undefined) {
		value.timeout = config.timeout
	}

	// Sort values order by key
	return Object.keys(value)
		.sort()
		.reduce((acc, key) => {
			acc[key as keyof T] = value[key as keyof T]
			return acc
		}, {} as T)
}

/**
 * We should not include plugin option values in the manifest.
 * They may contain sensitive information such as API keys or passwords.
 */
function redactPluginOptions(config: Config): Config {
	if (!config.plugins) {
		return config
	}

	const redactedPlugins = config.plugins.map((plugin): Plugin => {
		if (Array.isArray(plugin)) {
			const [pluginName, pluginOptions] = plugin

			if (typeof pluginOptions === 'object') {
				const redactedObj: Record<string, unknown> = {}

				for (const key in pluginOptions as Record<string, unknown>) {
					if (Object.prototype.hasOwnProperty.call(pluginOptions as Record<string, unknown>, key)) {
						redactedObj[key] = '[REDACTED]'
					}
				}

				return [pluginName, redactedObj]
			}
		}

		return plugin
	})

	return {
		...config,
		plugins: redactedPlugins
	}
}
